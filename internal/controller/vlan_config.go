/*
Copyright 2025 Latitude.sh.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
	"fmt"
	"net"
	"strings"
)

// VLANNetplanConfig holds configuration for generating VLAN netplan
type VLANNetplanConfig struct {
	VID       int    // VLAN ID number (e.g., 2011)
	Subnet    string // Subnet CIDR (e.g., "10.10.0.0/24")
	IPAddress string // IP address for this machine (e.g., "10.10.0.10")
	Interface string // Parent interface (defaults to eno2)
}

// GenerateVLANNetplanConfig generates the netplan configuration for a VLAN interface
func GenerateVLANNetplanConfig(cfg VLANNetplanConfig) string {
	if cfg.Interface == "" {
		cfg.Interface = "eno2"
	}

	// Calculate the mask from subnet
	_, ipNet, err := net.ParseCIDR(cfg.Subnet)
	maskSize := 24 // default
	if err == nil {
		maskSize, _ = ipNet.Mask.Size()
	}

	return fmt.Sprintf(`network:
  version: 2
  vlans:
    vlan.%d:
      id: %d
      link: %s
      addresses: [%s/%d]
`, cfg.VID, cfg.VID, cfg.Interface, cfg.IPAddress, maskSize)
}

// GenerateVLANSetupScript generates a shell script to configure VLAN interface
// This is injected into cloud-init to run early in the boot process
func GenerateVLANSetupScript(cfg VLANNetplanConfig) string {
	if cfg.Interface == "" {
		cfg.Interface = "eno2"
	}

	// Calculate the mask from subnet
	_, ipNet, err := net.ParseCIDR(cfg.Subnet)
	maskSize := 24 // default
	if err == nil {
		maskSize, _ = ipNet.Mask.Size()
	}

	return fmt.Sprintf(`#!/bin/bash
# VLAN Configuration Script - Auto-generated by CAPL
set -e

VLAN_VID=%d
VLAN_IP="%s"
VLAN_MASK=%d
PARENT_IFACE="%s"

echo "=== Configuring VLAN $VLAN_VID on $PARENT_IFACE ==="

# Create netplan configuration for VLAN
cat > /etc/netplan/60-vlan.yaml << EOF
network:
  version: 2
  vlans:
    vlan.$VLAN_VID:
      id: $VLAN_VID
      link: $PARENT_IFACE
      addresses: [$VLAN_IP/$VLAN_MASK]
EOF

chmod 600 /etc/netplan/60-vlan.yaml

# Apply netplan
echo "Applying netplan configuration..."
netplan apply 2>/dev/null || netplan generate && netplan apply

# Verify VLAN interface is up
for i in $(seq 1 30); do
  if ip link show vlan.$VLAN_VID 2>/dev/null | grep -q "state UP"; then
    VLAN_ACTUAL_IP=$(ip -4 addr show vlan.$VLAN_VID 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -1)
    if [ -n "$VLAN_ACTUAL_IP" ]; then
      echo "VLAN $VLAN_VID configured successfully with IP: $VLAN_ACTUAL_IP"
      exit 0
    fi
  fi
  echo "Waiting for VLAN interface to come up... ($i/30)"
  sleep 2
done

echo "WARNING: VLAN interface may not be fully configured"
ip addr show vlan.$VLAN_VID 2>/dev/null || echo "VLAN interface not found"
`, cfg.VID, cfg.IPAddress, maskSize, cfg.Interface)
}

// InjectVLANConfigIntoCloudInit injects VLAN configuration into cloud-init userdata
// It adds a write_files section for the netplan config and a runcmd to apply it
func InjectVLANConfigIntoCloudInit(userData string, cfg VLANNetplanConfig) string {
	if cfg.VID == 0 || cfg.IPAddress == "" || cfg.Subnet == "" {
		return userData
	}

	script := GenerateVLANSetupScript(cfg)

	// Create the cloud-init sections to inject
	writeFilesSection := fmt.Sprintf(`write_files:
  - path: /usr/local/bin/configure-vlan.sh
    permissions: '0755'
    content: |
%s
`, indentScript(script, 6))

	runcmdSection := `runcmd:
  - /usr/local/bin/configure-vlan.sh
`

	// Check if userData already has write_files or runcmd sections
	hasWriteFiles := strings.Contains(userData, "write_files:")
	hasRuncmd := strings.Contains(userData, "runcmd:")

	if hasWriteFiles && hasRuncmd {
		// Need to merge into existing sections
		// Add the file to existing write_files
		userData = injectIntoWriteFiles(userData, "/usr/local/bin/configure-vlan.sh", "0755", script)
		// Add the command to beginning of existing runcmd (so it runs first)
		userData = injectIntoRuncmd(userData, "/usr/local/bin/configure-vlan.sh", true)
	} else if hasWriteFiles {
		// Add to existing write_files and append runcmd
		userData = injectIntoWriteFiles(userData, "/usr/local/bin/configure-vlan.sh", "0755", script)
		userData = userData + "\n" + runcmdSection
	} else if hasRuncmd {
		// Prepend write_files and add to existing runcmd
		userData = writeFilesSection + "\n" + userData
		userData = injectIntoRuncmd(userData, "/usr/local/bin/configure-vlan.sh", true)
	} else {
		// No existing sections, just prepend both
		userData = writeFilesSection + "\n" + runcmdSection + "\n" + userData
	}

	return userData
}

// indentScript indents each line of a script by the specified number of spaces
func indentScript(script string, spaces int) string {
	indent := strings.Repeat(" ", spaces)
	lines := strings.Split(script, "\n")
	for i, line := range lines {
		if line != "" {
			lines[i] = indent + line
		}
	}
	return strings.Join(lines, "\n")
}

// injectIntoWriteFiles adds a file entry to an existing write_files section
func injectIntoWriteFiles(userData, path, permissions, content string) string {
	// Find write_files: section and add after it
	idx := strings.Index(userData, "write_files:")
	if idx == -1 {
		return userData
	}

	// Find the next line after write_files:
	newlineIdx := strings.Index(userData[idx:], "\n")
	if newlineIdx == -1 {
		return userData
	}

	insertPoint := idx + newlineIdx + 1

	entry := fmt.Sprintf(`  - path: %s
    permissions: '%s'
    content: |
%s
`, path, permissions, indentScript(content, 6))

	return userData[:insertPoint] + entry + userData[insertPoint:]
}

// injectIntoRuncmd adds a command to an existing runcmd section
func injectIntoRuncmd(userData, command string, prepend bool) string {
	// Find runcmd: section
	idx := strings.Index(userData, "runcmd:")
	if idx == -1 {
		return userData
	}

	// Find the next line after runcmd:
	newlineIdx := strings.Index(userData[idx:], "\n")
	if newlineIdx == -1 {
		return userData
	}

	insertPoint := idx + newlineIdx + 1
	entry := fmt.Sprintf("  - %s\n", command)

	if prepend {
		return userData[:insertPoint] + entry + userData[insertPoint:]
	}

	// Find the end of runcmd section (next section or end of file)
	// For simplicity, we'll just append after first entry
	return userData[:insertPoint] + entry + userData[insertPoint:]
}

// CalculateVLANIPAddress calculates an IP address for a machine within the VLAN subnet
// machineIndex is used to assign unique IPs (0 = .10, 1 = .11, etc.)
func CalculateVLANIPAddress(subnet string, machineIndex int) (string, error) {
	_, ipNet, err := net.ParseCIDR(subnet)
	if err != nil {
		return "", fmt.Errorf("invalid subnet CIDR: %w", err)
	}

	// Start from .10 to leave room for infrastructure IPs
	baseOffset := 10 + machineIndex

	ip := ipNet.IP.To4()
	if ip == nil {
		return "", fmt.Errorf("only IPv4 subnets are supported")
	}

	// Calculate the new IP
	newIP := make(net.IP, 4)
	copy(newIP, ip)

	// Add offset to the last octet (simple approach for /24 networks)
	// For larger networks, this would need more sophisticated logic
	newIP[3] = byte(baseOffset)

	return newIP.String(), nil
}
